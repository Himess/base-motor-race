<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Base Motor Race üèçÔ∏è</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(180deg, #1a0033 0%, #000033 100%);
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 400px;
            height: 100vh;
            background: linear-gradient(180deg, #0a0015 0%, #001a33 100%);
            overflow: hidden;
            box-shadow: 0 0 50px rgba(0, 150, 255, 0.3);
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #stats {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            padding: 0 20px;
            color: white;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(0, 150, 255, 0.8);
        }

        .stat {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #00ffff;
            font-size: 18px;
        }

        #hearts {
            display: flex;
            gap: 5px;
        }

        .heart {
            font-size: 24px;
            filter: drop-shadow(0 0 5px #ff0066);
        }

        #controls {
            position: absolute;
            bottom: 50px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            padding: 0 20px;
            pointer-events: auto;
        }

        .control-btn {
            width: 80px;
            height: 80px;
            background: rgba(0, 255, 255, 0.2);
            border: 3px solid #00ffff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            color: #00ffff;
            cursor: pointer;
            transition: all 0.1s;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            -webkit-tap-highlight-color: transparent;
        }

        .control-btn:active {
            transform: scale(0.9);
            background: rgba(0, 255, 255, 0.4);
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.8);
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 20;
            pointer-events: auto;
        }

        #startScreen h1, #gameOverScreen h1 {
            font-size: 48px;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
        }

        #startScreen p, #gameOverScreen p {
            font-size: 18px;
            margin-bottom: 30px;
            text-align: center;
            padding: 0 20px;
            line-height: 1.6;
        }

        .btn {
            padding: 15px 40px;
            font-size: 24px;
            background: linear-gradient(45deg, #00ffff, #0099ff);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.6);
            transition: all 0.3s;
        }

        .btn:active {
            transform: scale(0.95);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
        }

        #finalScore {
            font-size: 36px;
            margin: 20px 0;
            color: #00ffff;
        }

        .hidden {
            display: none !important;
        }

        /* Road lines animation */
        @keyframes roadLine {
            from { transform: translateY(-100px); }
            to { transform: translateY(100vh); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui">
            <div id="stats">
                <div class="stat">
                    <span id="score">0</span> m
                </div>
                <div class="stat" id="hearts">
                    <span class="heart">‚ù§Ô∏è</span>
                    <span class="heart">‚ù§Ô∏è</span>
                    <span class="heart">‚ù§Ô∏è</span>
                </div>
                <div class="stat">
                    <span id="speed">0</span> km/h
                </div>
            </div>

            <div id="controls">
                <div class="control-btn" id="leftBtn">‚óÑ</div>
                <div class="control-btn" id="rightBtn">‚ñ∫</div>
            </div>
        </div>

        <div id="startScreen">
            <h1>üèçÔ∏è BASE MOTOR RACE</h1>
            <p>
                Avoid the barriers!<br>
                Use Left ‚óÑ and Right ‚ñ∫ buttons to control<br>
                How far can you go with 3 lives?
            </p>
            <button class="btn" id="startBtn">START GAME</button>
        </div>

        <div id="gameOverScreen" class="hidden">
            <h1>GAME OVER!</h1>
            <div id="finalScore">0 m</div>
            <p>Great race! üèÅ</p>
            <button class="btn" id="mintNftBtn" style="margin-bottom: 15px;">üé® MINT AS NFT</button>
            <button class="btn" id="restartBtn">PLAY AGAIN</button>
            <div id="nftStatus" style="margin-top: 20px; font-size: 14px; color: #00ffff;"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const mintNftBtn = document.getElementById('mintNftBtn');
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const scoreEl = document.getElementById('score');
        const speedEl = document.getElementById('speed');
        const heartsEl = document.getElementById('hearts');
        const finalScoreEl = document.getElementById('finalScore');
        const nftStatusEl = document.getElementById('nftStatus');

        // Base Chain NFT Ayarlarƒ±
        const BASE_CHAIN_ID = 8453; // Base Mainnet
        const NFT_CONTRACT_ADDRESS = '0x...'; // Buraya NFT contract adresi gelecek
        
        // Web3 / Wallet baƒülantƒ±sƒ±
        let userAddress = null;
        let finalScoreValue = 0;

        // NFT Mint Fonksiyonu
        async function mintScoreNFT() {
            try {
                nftStatusEl.textContent = '‚è≥ Connecting wallet...';
                
                // MetaMask kontrol√º
                if (typeof window.ethereum === 'undefined') {
                    nftStatusEl.textContent = '‚ùå MetaMask not found! Please install MetaMask.';
                    nftStatusEl.style.color = '#ff0000';
                    return;
                }

                // C√ºzdan baƒülantƒ±sƒ±
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                userAddress = accounts[0];

                // Base Chain'e ge√ßi≈ü
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x2105' }], // 8453 hex
                    });
                } catch (switchError) {
                    // Base chain eklenmemi≈üse ekle
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [{
                                chainId: '0x2105',
                                chainName: 'Base',
                                nativeCurrency: {
                                    name: 'Ethereum',
                                    symbol: 'ETH',
                                    decimals: 18
                                },
                                rpcUrls: ['https://mainnet.base.org'],
                                blockExplorerUrls: ['https://basescan.org']
                            }]
                        });
                    }
                }

                nftStatusEl.textContent = 'üé® Creating NFT...';
                
                // NFT Metadata
                const metadata = {
                    name: `Base Motor Race #${finalScoreValue}m`,
                    description: `Amazing race with ${finalScoreValue} meters! üèçÔ∏è`,
                    image: await generateNFTImage(),
                    attributes: [
                        { trait_type: 'Distance', value: finalScoreValue },
                        { trait_type: 'Game', value: 'Base Motor Race' },
                        { trait_type: 'Date', value: new Date().toISOString() }
                    ]
                };

                // Burada normalde blockchain'e yazma i≈ülemi yapƒ±lƒ±r
                // Contract √ßaƒürƒ±sƒ± √∂rneƒüi (ger√ßek implementasyon gerekli):
                /*
                const contract = new ethers.Contract(
                    NFT_CONTRACT_ADDRESS, 
                    ABI, 
                    provider.getSigner()
                );
                const tx = await contract.mint(metadata);
                await tx.wait();
                */

                // ≈ûimdilik sim√ºle edelim
                await simulateMinting();

                nftStatusEl.textContent = `‚úÖ NFT minted successfully! Score: ${finalScoreValue}m`;
                nftStatusEl.style.color = '#00ff00';
                
                // IPFS veya Base chain'e kayƒ±t detaylarƒ±
                console.log('NFT Metadata:', metadata);
                console.log('User Address:', userAddress);

            } catch (error) {
                console.error('NFT Mint Error:', error);
                nftStatusEl.textContent = `‚ùå Error: ${error.message}`;
                nftStatusEl.style.color = '#ff0000';
            }
        }

        // NFT i√ßin g√∂rsel olu≈ütur (canvas snapshot)
        async function generateNFTImage() {
            return new Promise((resolve) => {
                // Oyun bittiƒüinde canvas'ƒ±n bir snapshot'ƒ±nƒ± al
                const imageData = canvas.toDataURL('image/png');
                resolve(imageData);
            });
        }

        // Mint i≈ülemini sim√ºle et (ger√ßek blockchain i≈ülemi i√ßin)
        function simulateMinting() {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve();
                }, 2000);
            });
        }

        // Canvas boyutlarƒ±nƒ± ayarla
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Oyun deƒüi≈ükenleri
        let gameRunning = false;
        let score = 0;
        let lives = 3;
        let speed = 3; // √áok yava≈ü ba≈ülangƒ±√ß
        let baseSpeed = 3;
        let lane = 1; // 0=sol, 1=orta, 2=saƒü
        let obstacles = [];
        let roadLines = [];
        let animationId;
        let obstacleSpawnTimer = 0;
        let gameTime = 0; // Oyun s√ºresi (frame cinsinden)
        
        // Hasar sistemi
        let isInvincible = false; // Hasar almazlƒ±k durumu
        let invincibilityTimer = 0; // Hasar almazlƒ±k s√ºresi
        let blinkTimer = 0; // Yanƒ±p s√∂nme efekti i√ßin
        const INVINCIBILITY_DURATION = 120; // 2 saniye (60 FPS * 2)
        
        // Yava≈ülama sistemi
        let slowdownActive = false;
        let slowdownTimer = 0;
        const SLOWDOWN_DURATION = 60; // 1 saniye
        const SLOWDOWN_AMOUNT = 0.5; // Hƒ±zƒ±n %50'si

        // Motor √∂zellikleri
        const bike = {
            width: 60,
            height: 100,
            y: 0,
            getLaneX() {
                // 5 ≈üerit: [ye≈üil][sol][orta][saƒü][ye≈üil]
                // Oynanabilir alanƒ±n geni≈üliƒüi
                const totalWidth = canvas.width;
                const greenLaneWidth = totalWidth / 5; // Her ≈üerit e≈üit
                const roadWidth = greenLaneWidth * 3; // Ortadaki 3 ≈üerit yol
                const roadStart = greenLaneWidth; // Sol ye≈üilikten sonra ba≈ülƒ±yor
                
                const laneWidth = roadWidth / 3;
                return roadStart + laneWidth * lane + laneWidth / 2 - this.width / 2;
            }
        };

        // Yol √ßizgileri olu≈ütur
        function initRoadLines() {
            roadLines = [];
            for (let i = 0; i < 10; i++) {
                roadLines.push({
                    y: i * 100,
                    // Yol kenarƒ± aƒüa√ßlarƒ± i√ßin rastgele deƒüerler
                    treeLeftY: Math.random() * canvas.height,
                    treeRightY: Math.random() * canvas.height,
                    grassOffset: Math.random() * 20
                });
            }
        }

        // Yol kenarlarƒ±nƒ± √ßiz (aƒüa√ßlar, √ßimler)
        function drawRoadSides() {
            // Yava≈ülama aktifse hƒ±zƒ± d√º≈ü√ºr
            let effectiveSpeed = speed;
            if (slowdownActive) {
                effectiveSpeed = speed * SLOWDOWN_AMOUNT;
            }
            
            const laneWidth = canvas.width / 5;
            const roadStart = laneWidth;
            const roadEnd = laneWidth * 4;

            // Sol ye≈üil ≈üerit (en sol)
            const leftGradient = ctx.createLinearGradient(0, 0, laneWidth, 0);
            leftGradient.addColorStop(0, '#1a3d1a');
            leftGradient.addColorStop(0.5, '#2d5a2d');
            leftGradient.addColorStop(1, '#3d6b3d');
            ctx.fillStyle = leftGradient;
            ctx.fillRect(0, 0, laneWidth, canvas.height);

            // Saƒü ye≈üil ≈üerit (en saƒü)
            const rightGradient = ctx.createLinearGradient(roadEnd, 0, canvas.width, 0);
            rightGradient.addColorStop(0, '#3d6b3d');
            rightGradient.addColorStop(0.5, '#2d5a2d');
            rightGradient.addColorStop(1, '#1a3d1a');
            ctx.fillStyle = rightGradient;
            ctx.fillRect(roadEnd, 0, laneWidth, canvas.height);

            // Yol kenarƒ± beyaz √ßizgileri
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            
            // Sol kenar √ßizgisi
            ctx.beginPath();
            ctx.moveTo(roadStart, 0);
            ctx.lineTo(roadStart, canvas.height);
            ctx.stroke();
            
            // Saƒü kenar √ßizgisi
            ctx.beginPath();
            ctx.moveTo(roadEnd, 0);
            ctx.lineTo(roadEnd, canvas.height);
            ctx.stroke();

            // √áim detaylarƒ± ve aƒüa√ßlar
            roadLines.forEach((line) => {
                const grassY = (line.y + line.grassOffset) % canvas.height;
                
                // Sol ye≈üil ≈üerit √ßimleri
                ctx.strokeStyle = '#4a7a4a';
                ctx.lineWidth = 1.5;
                for (let i = 0; i < 4; i++) {
                    const x = laneWidth * 0.2 + i * (laneWidth * 0.2);
                    ctx.beginPath();
                    ctx.moveTo(x, grassY);
                    ctx.lineTo(x - 1, grassY - 6);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x, grassY);
                    ctx.lineTo(x + 1, grassY - 5);
                    ctx.stroke();
                }

                // Saƒü ye≈üil ≈üerit √ßimleri
                for (let i = 0; i < 4; i++) {
                    const x = roadEnd + laneWidth * 0.2 + i * (laneWidth * 0.2);
                    ctx.beginPath();
                    ctx.moveTo(x, grassY);
                    ctx.lineTo(x - 1, grassY - 6);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(x, grassY);
                    ctx.lineTo(x + 1, grassY - 5);
                    ctx.stroke();
                }
            });

            // Aƒüa√ßlar - sol ve saƒü ye≈üil ≈üeritlere
            roadLines.forEach((line) => {
                // Sol ye≈üil ≈üeritte aƒüa√ßlar
                drawTree(laneWidth * 0.5, line.treeLeftY);
                
                // Saƒü ye≈üil ≈üeritte aƒüa√ßlar
                drawTree(roadEnd + laneWidth * 0.5, line.treeRightY);
                
                // Aƒüa√ßlarƒ± hareket ettir (yava≈ülama varsa daha yava≈ü)
                line.treeLeftY += effectiveSpeed * 0.8;
                line.treeRightY += effectiveSpeed * 0.8;
                
                if (line.treeLeftY > canvas.height) {
                    line.treeLeftY = -100;
                }
                if (line.treeRightY > canvas.height) {
                    line.treeRightY = -100;
                }
            });
        }

        // Aƒüa√ß √ßiz - daha ger√ßek√ßi
        function drawTree(x, y) {
            // G√∂vde
            ctx.fillStyle = '#3d2817';
            ctx.fillRect(x - 3, y + 15, 6, 20);

            // Ta√ß (koyu ye≈üil altta)
            ctx.fillStyle = '#2d5a2d';
            ctx.beginPath();
            ctx.arc(x, y + 5, 12, 0, Math.PI * 2);
            ctx.fill();

            // Ta√ß (orta ton)
            ctx.fillStyle = '#3d6b3d';
            ctx.beginPath();
            ctx.arc(x - 2, y + 2, 10, 0, Math.PI * 2);
            ctx.fill();

            // Ta√ß (a√ßƒ±k ye≈üil √ºstte)
            ctx.fillStyle = '#4a7a4a';
            ctx.beginPath();
            ctx.arc(x - 3, y, 7, 0, Math.PI * 2);
            ctx.fill();
        }

        // Yol √ßizgilerini √ßiz
        function drawRoadLines() {
            // Yava≈ülama aktifse hƒ±zƒ± d√º≈ü√ºr
            let effectiveSpeed = speed;
            if (slowdownActive) {
                effectiveSpeed = speed * SLOWDOWN_AMOUNT;
            }
            
            const laneWidth = canvas.width / 5;
            const roadStart = laneWidth;
            const roadLaneWidth = laneWidth; // Her yol ≈üeridi e≈üit
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            ctx.setLineDash([20, 20]);

            roadLines.forEach(line => {
                // Sol ≈üerit √ßizgisi (sol yol ≈üeridi ile orta arasƒ±nda)
                const line1X = roadStart + roadLaneWidth;
                ctx.beginPath();
                ctx.moveTo(line1X, line.y);
                ctx.lineTo(line1X, line.y + 50);
                ctx.stroke();

                // Saƒü ≈üerit √ßizgisi (orta ile saƒü yol ≈üeridi arasƒ±nda)
                const line2X = roadStart + roadLaneWidth * 2;
                ctx.beginPath();
                ctx.moveTo(line2X, line.y);
                ctx.lineTo(line2X, line.y + 50);
                ctx.stroke();

                // √áizgileri a≈üaƒüƒ± hareket ettir (yava≈ülama varsa daha yava≈ü)
                line.y += effectiveSpeed;

                // Ekranƒ±n altƒ±na ula≈ütƒ±ysa yukarƒ± ta≈üƒ±
                if (line.y > canvas.height) {
                    line.y = -50;
                    line.grassOffset = Math.random() * 20;
                }
            });

            ctx.setLineDash([]);
        }

        // Motor √ßiz
        function drawBike() {
            const x = bike.getLaneX();
            bike.y = canvas.height - 200;

            // Hasar almazlƒ±k durumunda yanƒ±p s√∂nme efekti
            if (isInvincible) {
                blinkTimer++;
                // Her 8 frame'de bir g√∂r√ºn√ºrl√ºƒü√º deƒüi≈ütir
                if (Math.floor(blinkTimer / 8) % 2 === 0) {
                    return; // Motor √ßizilmez (s√∂n√ºk)
                }
            }

            ctx.save();
            
            // Klasik Sportif Motor (G√ºm√º≈ü-Siyah)
            
            // Arka tekerlek - siyah lastik
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(x + 20, bike.y + 75, 14, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Arka tekerlek lastik detayƒ±
            ctx.strokeStyle = '#0a0a0a';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(x + 20, bike.y + 75, 14, 16, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // Arka jant - g√ºm√º≈ü
            ctx.fillStyle = '#b8b8b8';
            ctx.beginPath();
            ctx.ellipse(x + 20, bike.y + 75, 7, 9, 0, 0, Math.PI * 2);
            ctx.fill();

            // Arka s√ºspansiyon ve salƒ±ncak kolu
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(x + 20, bike.y + 60);
            ctx.lineTo(x + 28, bike.y + 40);
            ctx.stroke();

            // Motor g√∂vdesi - g√ºm√º≈ü metalik
            ctx.fillStyle = '#d0d0d0';
            ctx.fillRect(x + 22, bike.y + 35, 20, 25);
            
            // Motor g√∂lgesi
            ctx.fillStyle = '#9a9a9a';
            ctx.fillRect(x + 22, bike.y + 50, 20, 10);

            // Depo - klasik ≈üekil (g√ºm√º≈ü)
            ctx.fillStyle = '#c8c8c8';
            ctx.beginPath();
            ctx.ellipse(x + 32, bike.y + 30, 14, 10, 0, 0, Math.PI);
            ctx.fill();
            
            // Depo √ºst kƒ±sƒ±m
            ctx.fillStyle = '#e0e0e0';
            ctx.beginPath();
            ctx.ellipse(x + 32, bike.y + 28, 12, 8, 0, 0, Math.PI);
            ctx.fill();

            // Depo kapaƒüƒ±
            ctx.strokeStyle = '#5a5a5a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 32, bike.y + 25, 4, 0, Math.PI * 2);
            ctx.stroke();

            // Gidon ve √∂n baƒülantƒ±
            ctx.strokeStyle = '#3a3a3a';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x + 28, bike.y + 20);
            ctx.lineTo(x + 40, bike.y + 15);
            ctx.lineTo(x + 42, bike.y + 55);
            ctx.stroke();

            // Gidon tutacaƒüƒ±
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x + 35, bike.y + 15);
            ctx.lineTo(x + 45, bike.y + 15);
            ctx.stroke();

            // Sele - siyah deri
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(x + 28, bike.y + 38, 10, 6, -0.1, 0, Math.PI * 2);
            ctx.fill();
            
            // Sele diki≈üi
            ctx.strokeStyle = '#4a4a4a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + 22, bike.y + 38);
            ctx.lineTo(x + 34, bike.y + 38);
            ctx.stroke();

            // √ñn √ßamurluk - g√ºm√º≈ü
            ctx.fillStyle = '#b8b8b8';
            ctx.beginPath();
            ctx.arc(x + 42, bike.y + 65, 18, Math.PI, 0, true);
            ctx.fill();

            // √ñn tekerlek - siyah lastik
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(x + 42, bike.y + 75, 14, 16, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // √ñn tekerlek lastik detayƒ±
            ctx.strokeStyle = '#0a0a0a';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.ellipse(x + 42, bike.y + 75, 14, 16, 0, 0, Math.PI * 2);
            ctx.stroke();
            
            // √ñn jant - g√ºm√º≈ü
            ctx.fillStyle = '#b8b8b8';
            ctx.beginPath();
            ctx.ellipse(x + 42, bike.y + 75, 7, 9, 0, 0, Math.PI * 2);
            ctx.fill();

            // Jant telleri
            ctx.strokeStyle = '#9a9a9a';
            ctx.lineWidth = 1;
            for (let i = 0; i < 4; i++) {
                const angle = (i * Math.PI) / 2;
                ctx.beginPath();
                ctx.moveTo(x + 42, bike.y + 75);
                ctx.lineTo(x + 42 + Math.cos(angle) * 6, bike.y + 75 + Math.sin(angle) * 8);
                ctx.stroke();
            }

            // Far - yuvarlak klasik
            ctx.fillStyle = '#ffffcc';
            ctx.shadowColor = '#ffff99';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(x + 40, bike.y + 8, 7, 0, Math.PI * 2);
            ctx.fill();
            
            // Far √ßer√ßevesi
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#5a5a5a';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(x + 40, bike.y + 8, 7, 0, Math.PI * 2);
            ctx.stroke();
            
            // Far ƒ±≈üƒ±k huzmesi - daha yumu≈üak
            ctx.fillStyle = 'rgba(255, 255, 220, 0.08)';
            ctx.beginPath();
            ctx.moveTo(x + 40, bike.y + 8);
            ctx.lineTo(x + 30, bike.y - 50);
            ctx.lineTo(x + 50, bike.y - 50);
            ctx.closePath();
            ctx.fill();

            // Egzoz borusu - klasik krom
            ctx.strokeStyle = '#c0c0c0';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x + 15, bike.y + 55);
            ctx.lineTo(x + 10, bike.y + 75);
            ctx.stroke();

            // Egzoz ucu - siyah
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath();
            ctx.ellipse(x + 10, bike.y + 75, 3, 4, 0, 0, Math.PI * 2);
            ctx.fill();

            // Arka stop lambasƒ± - kƒ±rmƒ±zƒ± LED
            ctx.fillStyle = '#cc0000';
            ctx.beginPath();
            ctx.rect(x + 20, bike.y + 80, 6, 2);
            ctx.fill();

            ctx.restore();
        }

        // Engel olu≈ütur
        function createObstacle() {
            const randomLane = Math.floor(Math.random() * 3); // 0, 1, veya 2 (sol-orta-saƒü)
            const laneWidth = canvas.width / 5;
            const roadStart = laneWidth;
            const roadLaneWidth = laneWidth;
            
            const obstacleX = roadStart + roadLaneWidth * randomLane + roadLaneWidth / 2 - 30;
            
            obstacles.push({
                x: obstacleX,
                y: -100,
                width: 60,
                height: 80,
                lane: randomLane
            });
        }

        // Engelleri √ßiz ve hareket ettir
        function updateObstacles() {
            // Yava≈ülama aktifse hƒ±zƒ± d√º≈ü√ºr
            let effectiveSpeed = speed;
            if (slowdownActive) {
                effectiveSpeed = speed * SLOWDOWN_AMOUNT;
            }
            
            obstacles.forEach((obstacle, index) => {
                // Ger√ßek√ßi Trafik Bariyeri √ßiz
                ctx.save();

                // Bariyer ana g√∂vdesi (turuncu)
                ctx.fillStyle = '#ff6600';
                ctx.fillRect(obstacle.x + 5, obstacle.y, obstacle.width - 10, obstacle.height);

                // Beyaz reflekt√∂r ≈üeritleri
                ctx.fillStyle = '#ffffff';
                const stripeHeight = 12;
                const stripeCount = Math.floor(obstacle.height / (stripeHeight * 2));
                
                for (let i = 0; i < stripeCount; i++) {
                    const yPos = obstacle.y + i * (stripeHeight * 2) + 4;
                    ctx.fillRect(obstacle.x + 5, yPos, obstacle.width - 10, stripeHeight);
                }

                // Bariyer kenarlarƒ± (koyu gri)
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 4;
                ctx.strokeRect(obstacle.x + 5, obstacle.y, obstacle.width - 10, obstacle.height);

                // √úst kƒ±sƒ±m (koyu turuncu kap)
                ctx.fillStyle = '#cc5200';
                ctx.fillRect(obstacle.x, obstacle.y - 5, obstacle.width, 8);

                // Alt kƒ±sƒ±m (koyu turuncu taban)
                ctx.fillStyle = '#cc5200';
                ctx.fillRect(obstacle.x, obstacle.y + obstacle.height - 3, obstacle.width, 8);

                // Hafif g√∂lge efekti
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 8;
                ctx.shadowOffsetY = 5;

                ctx.restore();

                // Engeli a≈üaƒüƒ± hareket ettir (yava≈ülama varsa daha yava≈ü)
                obstacle.y += effectiveSpeed;

                // √áarpƒ±≈üma kontrol√º - sadece hasar almazlƒ±k yoksa
                if (!isInvincible && checkCollision(obstacle)) {
                    // Crash sesi √ßal
                    playCrashSound();
                    
                    // Can kaybƒ±
                    lives--;
                    updateHearts();
                    
                    // Hasar almazlƒ±k ba≈ülat
                    isInvincible = true;
                    invincibilityTimer = INVINCIBILITY_DURATION;
                    blinkTimer = 0;
                    
                    // Yava≈ülama ba≈ülat
                    slowdownActive = true;
                    slowdownTimer = SLOWDOWN_DURATION;
                    
                    // Engeli kaldƒ±r
                    obstacles.splice(index, 1);
                    
                    if (lives <= 0) {
                        gameOver();
                    }
                }

                // Ekranƒ±n altƒ±na ula≈ütƒ±ysa kaldƒ±r
                if (obstacle.y > canvas.height) {
                    obstacles.splice(index, 1);
                }
            });
        }

        // √áarpƒ±≈üma kontrol√º
        function checkCollision(obstacle) {
            const bikeX = bike.getLaneX();
            return (
                bikeX < obstacle.x + obstacle.width &&
                bikeX + bike.width > obstacle.x &&
                bike.y < obstacle.y + obstacle.height &&
                bike.y + bike.height > obstacle.y
            );
        }

        // Kalpleri g√ºncelle
        function updateHearts() {
            const hearts = heartsEl.querySelectorAll('.heart');
            hearts.forEach((heart, index) => {
                if (index >= lives) {
                    heart.style.opacity = '0.2';
                } else {
                    heart.style.opacity = '1';
                }
            });
        }

        // Oyun d√∂ng√ºs√º
        function gameLoop() {
            if (!gameRunning) return;

            // Ekranƒ± temizle
            ctx.fillStyle = 'rgba(10, 0, 21, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Yol kenarlarƒ±nƒ± √ßiz (aƒüa√ßlar, √ßimler)
            drawRoadSides();

            // Yol √ßizgilerini √ßiz
            drawRoadLines();

            // Motor √ßiz
            drawBike();

            // Engelleri g√ºncelle
            updateObstacles();

            // Oyun s√ºresini artƒ±r
            gameTime++;
            
            // Hasar almazlƒ±k s√ºresini g√ºncelle
            if (isInvincible) {
                invincibilityTimer--;
                if (invincibilityTimer <= 0) {
                    isInvincible = false;
                    blinkTimer = 0;
                }
            }
            
            // Yava≈ülama s√ºresini g√ºncelle
            if (slowdownActive) {
                slowdownTimer--;
                if (slowdownTimer <= 0) {
                    slowdownActive = false;
                }
            }
            
            // Saniye hesapla (60 FPS varsayƒ±mƒ±)
            const seconds = Math.floor(gameTime / 60);
            
            // Hƒ±z artƒ±≈üƒ± sistemi: Her 10 saniyede 0.4 hƒ±z artƒ±≈üƒ±
            const speedMultiplier = Math.floor(seconds / 10);
            const targetSpeed = baseSpeed + (speedMultiplier * 0.4);
            
            // Hƒ±zƒ± yumu≈üak bir ≈üekilde hedef hƒ±za yakla≈ütƒ±r
            if (speed < targetSpeed && targetSpeed <= 7.0) {
                speed += 0.002; // √áok yumu≈üak ge√ßi≈ü
            }
            
            // Yava≈ülama aktifse hƒ±zƒ± d√º≈ü√ºr (skor ve g√∂sterim i√ßin)
            let currentEffectiveSpeed = speed;
            if (slowdownActive) {
                currentEffectiveSpeed = speed * SLOWDOWN_AMOUNT;
            }
            
            // Motor sesini g√ºncelle
            updateEngineSound();
            
            // Skor artƒ±r (yava≈ülama varsa daha yava≈ü)
            score += currentEffectiveSpeed * 0.1;
            scoreEl.textContent = Math.floor(score);
            
            // Hƒ±zƒ± km/h olarak g√∂ster (daha anlamlƒ± sayƒ±lar i√ßin)
            speedEl.textContent = Math.floor(currentEffectiveSpeed * 30);

            // Kontroll√º bariyer olu≈üturma sistemi
            obstacleSpawnTimer++;
            
            // Hƒ±za g√∂re dinamik spawn aralƒ±ƒüƒ±
            // Yava≈üken: 100-180 frame arasƒ± (1.6-3 saniye)
            // Hƒ±zlƒ±yken: 70-130 frame arasƒ± (1.1-2.1 saniye)
            const minDelay = Math.max(70, 100 - (speed - baseSpeed) * 10);
            const maxDelay = Math.max(130, 180 - (speed - baseSpeed) * 15);
            const spawnDelay = minDelay + Math.random() * (maxDelay - minDelay);
            
            if (obstacleSpawnTimer > spawnDelay) {
                createObstacle();
                obstacleSpawnTimer = 0;
            }

            animationId = requestAnimationFrame(gameLoop);
        }

        // Oyunu ba≈ülat
        function startGame() {
            score = 0;
            lives = 3;
            speed = 3; // √áok yava≈ü ba≈ülangƒ±√ß
            baseSpeed = 3;
            lane = 1;
            obstacles = [];
            obstacleSpawnTimer = 0;
            gameTime = 0; // Oyun s√ºresini sƒ±fƒ±rla
            isInvincible = false; // Hasar almazlƒ±k kapalƒ±
            invincibilityTimer = 0;
            blinkTimer = 0;
            slowdownActive = false; // Yava≈ülama kapalƒ±
            slowdownTimer = 0;
            gameRunning = true;

            initRoadLines();
            updateHearts();

            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');

            // Sesleri ba≈ülat
            startAudio();

            gameLoop();
        }

        // Oyunu bitir
        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            
            finalScoreValue = Math.floor(score);
            finalScoreEl.textContent = finalScoreValue + ' m';
            gameOverScreen.classList.remove('hidden');
            nftStatusEl.textContent = ''; // √ñnceki mesajlarƒ± temizle
            nftStatusEl.style.color = '#00ffff';

            // Sesleri durdur
            stopAudio();
        }

        // Kontroller
        function moveLeft() {
            if (gameRunning && lane > 0) {
                lane--;
            }
        }

        function moveRight() {
            if (gameRunning && lane < 2) {
                lane++;
            }
        }

        // Event listeners
        startBtn.addEventListener('click', startGame);
        restartBtn.addEventListener('click', startGame);
        mintNftBtn.addEventListener('click', mintScoreNFT);

        // Mobil dokunmatik kontroller
        leftBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            moveLeft();
        });

        rightBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            moveRight();
        });

        // Mouse kontrolleri (desktop test i√ßin)
        leftBtn.addEventListener('click', moveLeft);
        rightBtn.addEventListener('click', moveRight);

        // Klavye kontrolleri
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') moveLeft();
            if (e.key === 'ArrowRight') moveRight();
            if (e.key === ' ' && !gameRunning) {
                if (!startScreen.classList.contains('hidden')) {
                    startGame();
                } else if (!gameOverScreen.classList.contains('hidden')) {
                    startGame();
                }
            }
        });

        // Arka plan m√ºziƒüi ve ses efektleri
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        let backgroundMusic = null;
        let engineSound = null;
        let musicNodes = [];

        // Crash ses efekti
        function playCrashSound() {
            // Metal √ßarpma sesi (noise + low frequency)
            const bufferSize = audioContext.sampleRate * 0.3;
            const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < bufferSize; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize / 5));
            }
            
            const noise = audioContext.createBufferSource();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            noise.buffer = buffer;
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(800, audioContext.currentTime);
            
            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
            
            noise.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);
            
            noise.start();
            
            // Ek metalik vuru≈ü sesi
            const impactOsc = audioContext.createOscillator();
            const impactGain = audioContext.createGain();
            
            impactOsc.frequency.setValueAtTime(100, audioContext.currentTime);
            impactOsc.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.1);
            
            impactGain.gain.setValueAtTime(0.2, audioContext.currentTime);
            impactGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
            
            impactOsc.connect(impactGain);
            impactGain.connect(audioContext.destination);
            
            impactOsc.start();
            impactOsc.stop(audioContext.currentTime + 0.1);
        }

        // Motor sesi olu≈ütur (synth ile)
        function createEngineSound() {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.type = 'sawtooth';
            oscillator.frequency.setValueAtTime(60 + speed * 3, audioContext.currentTime);
            
            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime); // Daha sessiz
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            return { oscillator, gainNode };
        }

        // Motor sesini g√ºncelle (hƒ±za g√∂re)
        function updateEngineSound() {
            if (engineSound && engineSound.oscillator) {
                engineSound.oscillator.frequency.setValueAtTime(
                    60 + speed * 3, 
                    audioContext.currentTime
                );
            }
        }

        // Hafif arka plan m√ºziƒüi (melodik)
        function createBackgroundMusic() {
            // Melodi notalarƒ± (C major scale - ne≈üeli)
            const melody = [
                { note: 523.25, duration: 0.4 }, // C
                { note: 587.33, duration: 0.4 }, // D
                { note: 659.25, duration: 0.4 }, // E
                { note: 783.99, duration: 0.4 }, // G
                { note: 659.25, duration: 0.4 }, // E
                { note: 587.33, duration: 0.4 }, // D
                { note: 523.25, duration: 0.8 }, // C
            ];

            let melodyIndex = 0;
            let nextNoteTime = audioContext.currentTime;

            // Hafif hi-hat
            function playHiHat(time) {
                const bufferSize = audioContext.sampleRate * 0.05;
                const buffer = audioContext.createBuffer(1, bufferSize, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize / 20));
                }
                
                const noise = audioContext.createBufferSource();
                const gain = audioContext.createGain();
                
                noise.buffer = buffer;
                gain.gain.setValueAtTime(0.02, time); // √áok daha sessiz
                
                noise.connect(gain);
                gain.connect(audioContext.destination);
                
                noise.start(time);
                
                musicNodes.push({ source: noise, gain });
            }

            // Melodik nota √ßal
            function playMelodyNote(time, frequency, duration) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                
                osc.type = 'sine'; // Yumu≈üak ton
                osc.frequency.setValueAtTime(frequency, time);
                
                // Fade in/out
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.08, time + 0.05); // Hafif ses
                gain.gain.linearRampToValueAtTime(0, time + duration);
                
                osc.connect(gain);
                gain.connect(audioContext.destination);
                
                osc.start(time);
                osc.stop(time + duration);
                
                musicNodes.push({ oscillator: osc, gain });
            }

            // M√ºzik d√∂ng√ºs√º
            function scheduleMusic() {
                if (!gameRunning) return;
                
                const currentTime = audioContext.currentTime;
                
                // Notalarƒ± planla
                while (nextNoteTime < currentTime + 0.2) {
                    const note = melody[melodyIndex];
                    
                    // Melodi √ßal
                    playMelodyNote(nextNoteTime, note.note, note.duration);
                    
                    // Hi-hat ekle (her nota ile)
                    playHiHat(nextNoteTime);
                    
                    nextNoteTime += note.duration;
                    melodyIndex = (melodyIndex + 1) % melody.length;
                }
                
                requestAnimationFrame(scheduleMusic);
            }
            
            scheduleMusic();
        }

        // Ses sistemini ba≈ülat
        function startAudio() {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            // Motor sesi ba≈ülat
            if (!engineSound) {
                engineSound = createEngineSound();
                engineSound.oscillator.start();
            }
            
            // Arka plan m√ºziƒüi ba≈ülat
            createBackgroundMusic();
        }

        // Sesleri durdur
        function stopAudio() {
            if (engineSound) {
                try {
                    engineSound.oscillator.stop();
                } catch (e) {
                    // Zaten durdurulmu≈ü
                }
                engineSound = null;
            }
            
            // M√ºzik nodlarƒ±nƒ± temizle
            musicNodes.forEach(node => {
                try {
                    if (node.oscillator) node.oscillator.stop();
                    if (node.source) node.source.stop();
                } catch (e) {
                    // Zaten durdurulmu≈ü
                }
            });
            musicNodes = [];
        }
    </script>
</body>
</html>
